<template lang="pug">
.onboardCrowd.center.mw7.pa4.mt5.br2.ba.b--moon-gray.lh-copy
  .onboardCrowd__init(v-if="isOnIntro")
    h1.mt0.f4.f3-ns æ­¡è¿åƒèˆ‡æ¨™è¨˜åŸå‹å·¥å…·æ¸¬è©¦ï¼
    p
      | æ¥ä¸‹ä¾†ï¼Œæˆ‘å€‘å°‡éš¨æ©ŸæŒ‘é¸å¹¾å€‹ ESG è£¡çš„é‡è¦æ¬„ä½ï¼Œä¾‹å¦‚ç¢³æ’æ”¾ã€å“¡å·¥äººæ•¸ï¼Œè«‹ä½ å”åŠ©å¾å ±å‘Šæ›¸ä¸­ï¼Œæ‰¾åˆ°ç­”æ¡ˆã€‚
      | å¦å¤–ï¼Œæˆ‘å€‘ä¹Ÿæœƒæ‰¾ä¸€äº›å…¶ä»–äººå·²ç¶“æ¨™è¨˜éçš„æ¬„ä½ï¼Œè«‹ä½ ç¢ºèªä»–å€‘çš„æ¨™è¨˜æ˜¯å¦æ­£ç¢ºã€‚
      | é€™äº›æ¬„ä½çš„é›£åº¦ä¸ä¸€ï¼Œæœ‰äº›éå¸¸ç°¡å–®ï¼Œæœ‰äº›å‰‡éœ€è¦è²»å¿ƒåˆ¤è®€ï¼Œæ‰€ä»¥å¦‚æœç™¼ç¾æ‰¾ä¸åˆ°ç­”æ¡ˆï¼Œè«‹ä¸è¦ç°å¿ƒï¼Œå¯ä»¥è·³åˆ°ä¸‹ä¸€é¡Œã€‚
      strong åœ¨ä»Šå¤©æ´»å‹•çµæŸå¾Œï¼Œæˆ‘å€‘æœƒè¨ˆç®—æ‰€æœ‰äººçš„ç©åˆ†ï¼Œä¸¦ä¸”ç™¼æ”¾ç´€å¿µå“çµ¦å‰å¹¾åçš„åƒèˆ‡è€…ã€‚
    p
      | ç”±æ–¼æ¸¬è©¦éœ€è¦é–±è®€ PDFï¼Œè«‹ç›¡é‡ä½¿ç”¨ 12" è¢å¹•ä»¥ä¸Šçš„è£ç½®ï¼Œæ‰èƒ½é †åˆ©æ“ä½œæ¨™è¨˜å·¥å…·ã€‚
      | å¦‚æœä½ æ‰‹é‚Šçš„è¢å¹•å¤ªå°ï¼Œä¹Ÿæ­¡è¿ç›´æ¥ä¾†æ‰¾æˆ‘å€‘å€Ÿç”¨ç­†é›»ã€‚
    p
      | åœ¨å¡«ç­”çµæŸå¾Œï¼Œæœƒè«‹ä½ å¡«å¯«ä½¿ç”¨å¿ƒå¾—çš„å•å·ï¼Œå•å·çš„å¡«ç­”è³‡æ–™ï¼Œæœƒä»¥ CC0 çš„æ–¹å¼æˆæ¬Šå…¬é–‹ï¼Œè«‹è¨˜å¾—ä¸è¦å¡«å¯«æ•æ„Ÿè³‡è¨Š ğŸ¥¹ã€‚
      | æœ€å¾Œï¼Œé™¤äº†å•å·å¤–ï¼Œä¹Ÿæ­¡è¿éš¨æ™‚æ‰¾æˆ‘å€‘èŠèŠï¼Œæä¾›ä½ çš„ä½¿ç”¨å¿ƒå¾—ï¼Œæˆ–æ˜¯å°æ–¼å·¥å…·çš„å»ºè­°ã€‚
    .bb.ph4.b--moon-gray.mv4
    form(@submit.prevent="prepareQuestions")
      label.db.mb3(for="userId")
        .dark-gray.f6.mb1 è«‹è¼¸å…¥ä½ çš„æš±ç¨±ï¼Œä½œç‚ºçµ±è¨ˆç©åˆ†è¨ˆç®—ä½¿ç”¨
        input(v-model.trim="userId" type="text")
      button.pv2.ph4(type="submit" :disabled="!canStartPrepare || isOnLoadingRecords")
        | {{ loadingLabel }}
  .onboardCrowd__empty(v-else-if="hasNoPendingJobs")
    h1.mt0.f4.f3-ns æ‰€æœ‰é¡Œç›®éƒ½å·²ç¶“è¢«æ¨™è¨˜å®Œæˆï¼
    p è«‹æœŸå¾…æœ¬æ—¥çš„æˆæœå ±å‘Šï¼Œæˆ–ä¾†æ‰¾æˆ‘å€‘èŠèŠä½ çš„ä½¿ç”¨å¿ƒå¾—ã€‚
  .onboardCrowd__ready(v-else)
    h1.mt0.f4.f3-ns æŠ½ç±¤å®Œæˆï¼ä»¥ä¸‹æ˜¯æƒ³è«‹ä½ å”åŠ©æ¨™è¨˜çš„é¡Œç›®ï¼š
    .mv3(v-if="fieldsToSubmit.length")
      .mb2.f4 è¦
        strong æ¨™è¨˜
        | çš„å ±å‘Šæ›¸èˆ‡æ¬„ä½
      .flex.items-center.f6.gray(v-for="field in fieldsToSubmit" :key="field.label")
        .flex-none.mr2.fw5 {{ field.company.name }}
        .flex-auto.b {{ field.category }} | {{ field.label }}
    .mv4(v-if="fieldsToVerify.length")
      .mb2.f4 è¦
        strong é©—è­‰
        | çš„å ±å‘Šæ›¸èˆ‡æ¬„ä½
      .flex.items-center.f6.gray(v-for="field in fieldsToVerify" :key="field.label")
        .flex-none.mr2.fw5 {{ field.company.name }}
        .flex-auto.b {{ field.category }} | {{ field.label }}
    button.pv2.ph4(@click="kickoff") é–‹å§‹æ¨™è¨˜èˆ‡é©—è­‰
</template>
<script setup lang="ts">
import _ from 'lodash'
import fieldMap from '~/assets/field-map.yml'
import reportMap from '~/assets/report-list.yml'

const emit = defineEmits(['userId', 'tasks'])

const airtable = useAirtable()

const isOnIntro = ref(true)
const isOnLoadingRecords = ref(false)
const hasNoPendingJobs = ref(false)

const userId = ref('')
const fieldsToSubmit = ref([])
const fieldsToVerify = ref([])

const loadingLabel = computed(() => {
  if (!isOnLoadingRecords.value) {
    return 'è¼‰å…¥é¡Œåº«'
  } else {
    return 'æ©Ÿå™¨äººæ­£åœ¨å¹«å¿™æŠ½ç±¤ä¸­... ğŸ¤–'
  }
})

const canStartPrepare = computed(() => {
  return userId.value.length > 0
})

async function prepareQuestions () {
  isOnLoadingRecords.value = true
  let pendingRecords = []
  try {
    pendingRecords = await airtable.getPendingFields(userId.value)
  } catch (err) {
    alert(err)
  }

  await new Promise((resolve) => {
    // do simple random backoff, so to avoid Airtable rate limit
    setTimeout(resolve, 300 + Math.random() * 2000)
  })

  let pendingVerifications = []
  try {
    pendingVerifications = await airtable.getPendingVerifications(userId.value)
  } catch (err) {
    alert(err)
  }

  const submissionTasks = findSomeSubmissionTasks(pendingRecords)
  const verificationTasks = findSomeVerificationTasks(pendingVerifications)

  isOnIntro.value = false

  if (!submissionTasks.length && !verificationTasks.length) {
    hasNoPendingJobs.value = true
  } else {
    fieldsToSubmit.value = submissionTasks
    fieldsToVerify.value = verificationTasks
  }
  isOnLoadingRecords.value = false
}

const allFields = fieldMap.flatMap((category) => {
  return category.fields.map((field) => {
    return {
      category: category.category,
      ...field
    }
  })
})

function findSomeVerificationTasks (pendingRecords, nVerify = 6) {
  // æ±ºå®šé©—è­‰çš„æ¬„ä½ï¼Œä»¥åŒå…¬å¸ç‚ºå„ªå…ˆ
  const topRecordPool = _.shuffle(pendingRecords.slice(0, nVerify * 3))
  const topCompanies = _.uniq(topRecordPool.map(r => r.get('å…¬å¸çµ±ç·¨')))
  const companyWeight = topCompanies.reduce((acc, id, weight) => {
    acc[id] = weight
    return acc
  }, {})

  topRecordPool.sort((a, b) => {
    return companyWeight[a.get('å…¬å¸çµ±ç·¨')] - companyWeight[b.get('å…¬å¸çµ±ç·¨')]
  })

  const normalizedRecords = topRecordPool
    .slice(0, nVerify)
    .map((record) => {
      const company = reportMap[0].reports.find(r => r.id === record.get('å…¬å¸çµ±ç·¨'))
      const targetField = allFields.find((field) => {
        return field.label === record.get('æ¬„ä½æ¨™ç±¤')
      })
      return {
        company,
        year: record.get('å ±å‘Šæ›¸å¹´ä»½'),
        data: record,
        ...targetField
      }
    })

  return normalizedRecords
}

function findSomeSubmissionTasks (pendingRecords, nSubmit = 2) {
  const reportedCompanies = _.shuffle(_.uniq(pendingRecords.map(r => r.get('å…¬å¸çµ±ç·¨'))))
  const year = reportMap[0].year
  const allCompanies = reportMap[0].reports.map(r => r.id)
  const nonReportedCompanies = _.shuffle(_.difference(allCompanies, reportedCompanies))

  // æ±ºå®šåˆ¤è®€çš„å…¬å¸èˆ‡æ¬„ä½ï¼Œå…ˆä»¥æ²’äººåšéçš„å…¬å¸ç‚ºå„ªå…ˆ
  const potentialCompanies = nonReportedCompanies.length ? nonReportedCompanies : reportedCompanies
  const company = potentialCompanies[0]

  const reportedFields = pendingRecords
    .filter(r => r.get('å…¬å¸çµ±ç·¨') === company)
    .map(r => r.get('æ¬„ä½æ¨™ç±¤'))

  const nonReportedFields = _.shuffle(_.difference(allFields, reportedFields))

  const companyInfo = reportMap[0].reports.find(r => r.id === company)
  const taskFields = nonReportedFields
    .slice(0, nSubmit)
    .map((field) => {
      return {
        company: companyInfo,
        year,
        ...field
      }
    })

  return taskFields
}

function kickoff () {
  emit('userId', userId.value)
  emit('tasks', {
    submissions: fieldsToSubmit.value,
    verifications: fieldsToVerify.value
  })
}

</script>
